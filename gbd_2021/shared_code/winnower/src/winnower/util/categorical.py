"""
Functions for overcoming issues between Stata and pandas Categorical concepts.

Here's a brief summary matrix

                    Stata       pandas
Value Type          numeric     numeric
Label Type          string      object
Unique Labels?      NO          YES
Missing Labels?     YES         NO

Common problems that must be dealt with are:
    Not all values are labeled
    Some labels are duplicated (e.g., "Other")
"""
import collections
import re
import logging

import attr
import pandas

from winnower import errors
from winnower.util.dtype import (
    is_categorical_dtype,
    is_integer_dtype,
    is_string_dtype,
    is_float_dtype,
)

logger = logging.getLogger(__loader__.name)


def get_ordered_categories(series):
    """
    Returns an list of categories ordered by ascending code values.

    Args:
        series: Categorical series and pandas.Series having of dtype
                CategoricalDtype.

    If the series is not CategoricalDtype an error is raised.

    If the categorical is already ordered categories are returned unchanged.

    If the categorical is unordered then a new list is created and the category
    labels are added in ascending category code order. For example: if the
    series has categories ["bar", "eggs", "foo", "spam"] and equivalent codes
    of [1, 3, 0, 2] then the ordered category list that is returned will
    contain: ["foo", "bar", "spam", "eggs"].

    NOTES: By default Categorical columns are created unordered. When this
    occurs codes are NOT generated on first appearance in the Series, as one
    might expect, instead all labels are sorted alphabetically and then codes
    are generated by numbering the sorted labels starting from 0. This means
    that when the categories attribute of a Categorical is inspected the
    categories will appear in alphabetical order. This can lead to some
    confusion when attempting to determine a mapping of codes to labels as that
    mapping can shift (for unordered categoricals) depending on how
    a categorical series is sliced.

    For example. If a categorical series is created using ["foo", "bar",
    "spam", "eggs"] one might naively expect the category code to label map to
    look as follows: {0: "foo", 1: "bar", etc...} However, the actual map looks
    like this: {0: "bar", 1: "eggs", 2: "foo", 3: "spam"}. Note the labels in
    alphabetical order.

    The implication is that for unordered categoricals the original mapping of
    codes to labels cannot be determined.

    This can be particularly troublesome for category labels that have no
    values in the series.
    """

    if not is_categorical(series):
        raise errors.ValidationError("Series is not Categorical")

    if is_ordered(series):
        logger.debug("Series is ordered categorical "
                     "returing category labels as is.")
        return list(series.dtype.categories)

    logger.warning("series is NOT ordered categorical! "
                   "This can cause problems!!")
    logger.debug(f"Defined cats: {category_labels(series)}.")
    # Filter the values down to unique values that are not NaN
    s = series.dropna()  # returns a pandas.Categorical
    # Only category labels that are actually represented in the series will be
    # returned.
    cats = list(s.unique())
    logger.debug(f"Unordered cats: {cats}.")
    codes = list(s.cat.codes.unique())
    logger.debug(f"Unordered codes: {codes}.")
    ordered_cats = []

    # It is possible that there are more category labels defined than are
    # actually used in the data set for this reason stand-in labels are
    # generated for codes that don't appear in our unique codes.
    for i in range(0, len(category_labels(series))):
        if i in codes:
            idx = codes.index(i)
            ordered_cats.append(cats[idx])
        else:
            ordered_cats.append(standin_label(i))

    return ordered_cats


def get_categorical_superset(left, right):
    """
    Returns an list of categorical labels in ascending category code order.

    Args:
        left: A Categorical series. The category labels in left will be used as
              the initial set and will be preferred when there is a conflict.
        right: A Categorical series. The category labels in right are used to
               update those in the left that are <standin ... > labels and
               extend those in left if right has more.
    """

    # Get an ordered list of categories. These categories must be ordered so
    # that the category list index matches the category code in the series.
    try:
        left_cats = get_ordered_categories(left)
    except errors.ValidationError:
        raise errors.Error("Left series needs CategoricalDtype "
                           f"but got {left.dtype}")

    try:
        right_cats = get_ordered_categories(right)
    except errors.ValidationError:
        raise errors.Error("Right series needs CategoricalDtype "
                           f"but got {right.dtype}")

    l_ordered = is_ordered(left)
    r_ordered = is_ordered(right)
    superset = []

    if l_ordered and r_ordered:
        logger.debug("Both categoricals are ordered.")
        # Begin by gathering all the valid labels in the left set.
        # zip stops when the first iterable is exhausted
        for l, r in zip(left_cats, right_cats):
            logger.debug(f"l: {l}, r {r}.")
            if l == r:  # noqa
                superset.append(l)
            elif is_standin_label(l):
                logger.warning(f"Replacing stand-in label {l} with {r}")
                superset.append(r)
            else:  # neither are fake - default to left
                msg = (f"Categories differ - {l!r} vs {r!r} - "
                       f"using {l!r}")
                logger.warning(msg)
                superset.append(l)
        # Then extend the new list by those remaining in
        # the longer category list.
        if len(left_cats) >= len(right_cats):
            superset.extend(left_cats[len(right_cats):])
        else:
            superset.extend(right_cats[len(left_cats):])
        # test result and ensure no duplication
        ctr = collections.Counter(superset)
        if len(ctr) != len(superset):  # duplication!
            dupe_values = [k for k, v in ctr.items() if v > 1]
            dupe_explanations = []
            for dv in dupe_values:
                li = left_cats.index(dv)
                # ri = right_cats.index(dv)
                dupe_explanations.append(
                    f"{dv!r} and {right_cats[li]!r} are both set to {dv!r}")

            msg = ("Cannot compute superset of categories with left categories"
                   f" {left_cats} and right categories {right_cats} because "
                   "left categories are preferred but this leads to codes from"
                   " the right dataset being lost.\n"
                   "Details: \n\t{}".format("\n\t".join(dupe_explanations))
                   )
            raise errors.Error(msg)
        return superset

    logger.warning("Attempting to order unordered categories! "
                   "This will not always work!!")
    # Otherwise it gets difficult.
    for lidx, l in enumerate(left_cats):
        # Order doesn't matter so assume that if the label is in right then
        # there is a match.
        if l in right_cats:
            superset.append(l)
            continue

        if r_ordered:
            # Ok, right is ordered. If we squint hard it might make sense to
            # use the label we find in right that matches the current left
            # index.
            if is_standin_label(l) and lidx < len(right_cats):
                rtmp = right_cats[lidx]
                # Only include it though if superset doesn't already have it.
                if rtmp not in superset:
                    superset.append(rtmp)
                else:
                    superset.append(l)
        # Right is not ordered so it doesn't make sense to get labels by index.
        else:
            superset.append(l)

    # Add any others we find at the end
    def exclude(val):
        if is_standin_label(val):
            return True

        return val in superset

    right_extra = [r for r in right_cats if not exclude(r)]
    if right_extra:
        superset.extend(right_extra)

    return superset


def category_codes(series, *, nan_val=float('NaN')):
    """
    Returns the category codes from a series, discarding the labels.

    Args:
        series: series to return category codes from

    Optional Keyword Args:
        nan_val (default NaN): value to fill in for NaN values.
    """
    # -1 is a special code referring to NaN values (no other neg codes allowed)
    return pandas.Series(series.cat.codes, name=series.name,
                         index=series.index).replace(-1, nan_val)


def category_labels(series, *, as_series=False):
    """
    Returns the category labels from a series.

    Args:
        series: series to return category labels from.
    """
    res = series.cat.categories
    if as_series:
        return pandas.Series(res)
    else:
        return res


def is_categorical(series: pandas.Series):
    # Per pandas this is the way to do it
    # https://pandas.pydata.org/pandas-docs/stable/categorical.html
    return hasattr(series, 'cat')


def to_Categorical(series, labels, *, ordered=True):
    """
    Converts a series to a categorical by labelling the values.

    Values should be integers 0 and larger. The value -1 is also allowed and is
    used to mark NaN values.

    Args:
        series: a pandas.Series of integer values or values that can be
            converted to int.
        labels: a list, tuple, or dict.
            list/tuple: string lables corresponding to the value by index.
            dict: numeric keys with string lables as values.

    Raises:
        Error: series contains negative values or non-integer values.
        RequiredInputsMissing: if labels are missing for one or more values.

    Returns the converted series.

    >>> sex_id = pandas.Series([0, 0, 0, 1])
    >>> labeled = to_Categorical(sex_id, {0: 'Male', 1: 'Female'})
    """
    if series.min() < -1:
        raise errors.Error("Categorical values cannot be negative, except -1 "
                           "which denotes 'NaN'")

    # fill NaN values with -1 in case the input dtype supports NaN (e.g., float
    # values).
    codes = pandas.to_numeric(series.fillna(-1), downcast='integer')

    # downcast='integer' does not guarantee integer dtype - only that values
    # will be downcast to integer if the values allow for it
    if not is_integer_dtype(codes.dtype):
        raise errors.Error("Categorical values must be integers")

    unique_codes = codes.unique()

    if isinstance(labels, (list, tuple)):
        max_code = len(labels)
        missing = [str(val) for val in unique_codes if val >= max_code]
    elif isinstance(labels, dict):
        missing = [str(val) for val in unique_codes
                   if val not in labels and val != -1]
        labels = _labels_dict_to_list(labels)
    else:
        t = type(labels).__name__
        raise errors.Error(f"Must provide list or dict for labels, not {t}")

    if missing:
        missing.sort()
        err_msg = f"No labels for values: {', '.join(missing)}"
        raise errors.RequiredInputsMissing(err_msg)

    categorical = pandas.Categorical.from_codes(codes, labels, ordered=ordered)
    return pandas.Series(categorical, index=series.index)


def undefined_label(value):
    """
    Return an undefined label for a value that is an unmapped category.

    Used to generate undefined filler labels as pandas requires ALL
    category values to be unique.
    """
    return f"<undefined category for {value}>"


def is_undefined_label(label):
    re_match = r'<undefined category for [^>]+>$'
    if isinstance(label, pandas.Series) and is_string_dtype(label):
        return label.str.match(re_match)
    else:
        return bool(re.match(re_match, label))


def standin_label(value):
    """
    Return a template label for value.

    Used to generate filler labels as pandas requires ALL category values
    in the range 0...max_category_code are defined.
    """
    return f"<stand-in category for {value}>"


def is_standin_label(label):
    return bool(re.match('<stand-in category for [^>]+>$', label))


class CategoryFixer:
    """
    Fixes category labels to play nicely with pandas.
    """
    # Special token we use as part of renaming
    RENAME_DELIM = '‚êÉ'  # End of text AKA '\u2403'
    # Template for renaming a label
    RENAME_TEMPLATE = f"{{label}}{RENAME_DELIM}({{value}})"
    # Regex to match RENAME_TEMPLATE
    RENAME_MATCHER = re.compile(rf'^(.+){RENAME_DELIM}\((:?.+)\)$')

    def clean_value_map(self, value_map: dict):
        """
        Cleans a value map to ensure that labels do not error pandas.

        For this method, and sub-methods, "value" will refer to a key in a a
        dictionary and "label" will refer to a value.

        In other words, we have {value: label} pairs.

        This can mutate value_map.
        """
        self._rename_duplicate_labels(value_map)
        remapped_values = self._reassign_negative_values(value_map)
        return value_map, remapped_values

    def _rename_duplicate_labels(self, value_map):
        # Map of {label: all_values_using_label}
        reverse_map = collections.defaultdict(list)
        for k, v in value_map.items():
            reverse_map[v].append(k)

        # Rename labels to include original key, for repeated labels
        for label, values in reverse_map.items():
            if len(values) == 1:
                continue
            for value in values:
                value_map[value] = self.RENAME_TEMPLATE.format(label=label,
                                                               value=value)

    def _reassign_negative_values(self, value_map):
        """
        Re-assigns negative values to positive values, if necessary.

        Negative codes are not supported by pandas Categoricals, so this must
        be done.

        Returns dict of {negative_value: positive_value}.

        This mutates value_map.
        """
        to_reassign = [int(X) for X in value_map if X < 0]
        if not to_reassign:
            return {}

        to_reassign.sort()  # most negative first
        max_val = int(max(value_map))
        remapped_values = {}

        for new_value, neg_value in enumerate(to_reassign, start=max_val + 1):
            value_map[new_value] = value_map.pop(neg_value)
            remapped_values[neg_value] = new_value

        return remapped_values

    def extract_labels(self, categorical: pandas.Series) -> pandas.Series:
        """
        Extract the labels from a pandas Categorical series.

        This "un-cleans" the labels if they had been cleaned.
        """
        uncleaned_labels = []
        for label in categorical:
            if pandas.isnull(label):
                uncleaned_labels.append('')
                continue

            if is_undefined_label(label):
                uncleaned_labels.append('')
                continue

            # Otherwise ...
            m = self.RENAME_MATCHER.match(label)
            if m:
                uncleaned_labels.append(m.groups()[0])
            else:  # not cleaned by us
                uncleaned_labels.append(label)

        return pandas.Series(uncleaned_labels, index=categorical.index)


def _labels_dict_to_list(labels: dict):
    result = []
    for i in range(max(labels) + 1):
        try:
            result.append(labels[i])
        except KeyError:
            result.append(standin_label(i))
    return result


@attr.s
class StandardizedCategoryResult:
    """
    Result object produced by CategoryStandardizer.

    Args:
        left: pandas.Series with categorical dtype.
        right: pandas.Series with categorical dtype.
        categories: list of str categories used by left/right.
    """
    left = attr.ib()
    right = attr.ib()
    categories = attr.ib()


class CategoryStandardizer:
    """
    Standardizes two series to be compatible categoricals.

    It takes 2 series, one of which must have a categorical dtype, and returns
    a StandardizedCategoryResult where both 'left' and 'right' series are
    categoricals.

    In the case of two categorical inputs, the category labels are consolidated
    into a superset. In case of conflict the LEFT labels are preferred.

    In the case of a categorical and a str input, the str is converted to a
    categorical. Any str values not in the categoricals labels are added.

    In the case of a categorical and a numeric input, the numeric is converted
    to a categorical labeled appropriately per the categorical's labels. If
    additional labels are necessary for codes not in the categorical they are
    created.

    Do not use directly. Use update_with_compatible_categories.
    """
    def make_compatible(self, left, right):
        l_is_cat = is_categorical_dtype(left)
        r_is_cat = is_categorical_dtype(right)

        if l_is_cat and r_is_cat:
            left, right, categories = self._consolidate_cats(left, right)
        elif l_is_cat:  # implies r is not
            right, categories, left = self._categorize(right, context=left)
        elif r_is_cat:
            left, categories, right = self._categorize(left, context=right)
        else:
            msg = "Neither series is categorical. Why did you call this?"
            raise errors.Error(msg)

        return StandardizedCategoryResult(left, right, categories)

    def _consolidate_cats(self, left, right):
        # if either is ordered, both shall be ordered
        ordered = is_ordered(left) or is_ordered(right)
        # errors if one category is not a superset of the other
        categories = get_categorical_superset(left, right)
        left_res = set_labels(left, categories, ordered=ordered)
        right_res = set_labels(right, categories, ordered=ordered)
        return left_res, right_res, categories

    def _categorize(self, s: pandas.Series, *, context):
        """
        Convert s to a categorical series given contextual series context.

        As s may contain values not present in context this means that both s
        and context may be modified, so be sure the code calling this behaves
        accordingly.
        """
        labels = category_labels(context)
        ordered = is_ordered(context)

        if is_integer_dtype(s) or is_float_dtype(s):
            # assume s contains codes; label the codes to create a categorical
            # Downcast gently to check codes for floating point numbers.
            s = downcast_float_to_integer(s)

            new_codes = [code for code in s.unique()
                         # a code's label is labels[code]
                         if code >= len(labels)]
            if new_codes:
                # get superset of labels and update both s and context
                labels_ss = labels.tolist()
                labels_ss.extend(map(standin_label, new_codes))
                s_as_cat = to_Categorical(s, labels_ss, ordered=ordered)
                context_fixed, s_fixed, categories = self._consolidate_cats(
                    context, s_as_cat)
            else:
                # convert s to a categorical
                s_fixed = to_Categorical(s, labels.tolist(), ordered=ordered)
                categories = labels.tolist()
                context_fixed = context
        else:
            # assume s contains labels; create categorical using correct codes
            label_set = set(labels)
            # label series cannot have 'NaN's
            s = s.dropna()

            new_labels = [label for label in s.unique()
                          if label not in label_set]
            if new_labels:
                label_ss = self._label_superset(labels, new_labels)
                s_as_cat = pandas.Series(
                    pandas.Categorical(s, label_ss, ordered))
                context_fixed, s_fixed, categories = self._consolidate_cats(
                    context, s_as_cat)
            else:
                s_fixed = s.astype(context.dtype)
                categories = labels.tolist()
                context_fixed = context

        return s_fixed, categories, context_fixed

    def _label_superset(self, labels, new_labels):
        """
        Compute superset of labels given existing labels and new labels to add.

        This could be made more efficient by detecting stand-in labels and
        removing them, adding a new label at that index. This would slightly
        reduce overhead by efficiently eliminating fake labels generated by
        winnower just to solve the impedence mismatch between pandas
        categoricals and Stata value labels.
        """
        result = labels.tolist()
        result.extend(new_labels)
        return result


update_with_compatible_categories = CategoryStandardizer().make_compatible


def is_ordered(s: pandas.Series):
    """
    Predicate: is this categorical ordered?

    raises Error if s is not a categorical.
    """
    if not is_categorical_dtype(s):
        raise errors.Error(f"Series {s.name} is not a categorical")
    return s.cat.ordered


def set_labels(s: pandas.Series, categories, *, ordered=None):
    """
    Return updated copy of s with new labels.
    """
    # set_categories uses the existing ordered value by default
    if ordered is None:
        ordered = is_ordered(s)

    if not ordered:
        logger.warning(f"set_categories: {s.name} is not ordered. "
                       "This can cause problems")
    # rename=True indicates that codes should remain consistent, but labels may
    # change (e.g., the code is renamed)
    # NOTE: if the new set of categories is smaller than the old set then all
    # codes that no longer have labels will be set to NaN (code == -1)
    return s.cat.set_categories(categories, ordered=ordered, rename=True)


def downcast_float_to_integer(s: pandas.Series):
    """
    Downcast float series to integer. This is to check if the
    current float series was inadvertently upcasted from int to float
    previously.

    Args:
        s: pandas.Series to check dtype of.
    """
    s = pandas.to_numeric(s.fillna(-1), downcast='integer')
    if not is_integer_dtype(s):
        raise errors.Error("Error: Integer Series expected! "
                           f"Check values in Series: {s.name}")
    return s
