###################################################################################################################################################
# Zero Survivor Correction Script
# Description: estimates number of missing siblings due to zero reporter bias

###################################################################################################################################################


#Configure R
library(readr)
library(data.table)
library(plyr)
library(dplyr)
library(parallel)
library(mortdb, lib="FILEPATH")
rm(list=ls())

# Read in arguments
args <- commandArgs(trailingOnly = T)
input_dir <- args[1]
output_dir <- input_dir

# Load in formatted sib history
input <- fread(FILEPATH)
input[, yod := as.integer(yod)]

for (survey in unique(input$svy)) {
  survey_spec <- input[svy==survey,]


  # ----------------------
  # Preformatting:


  # get rid of nonsensical years of birth
  survey_spec[yob<0, yob := NaN]

  # smallest interview year
  min_interview_yr <- min(survey_spec[,yr_interview])

  # count number of females in a sibship, only conducting this analysis for females
  sibsizes <- survey_spec[sex==2,.N, by='id']
  survey_spec <- merge(survey_spec,sibsizes,by='id',all.x=T,sort=T)

  #assign age cohorts
  survey_spec[,cohort := ((yr_interview-yob)%/%5)*5]
  survey_spec[cohort > 85, cohort := NA]

  #generate ageresp
  survey_spec[,ageresp := yr_interview - yob]

  #sort by id, sibid
  survey_spec <- survey_spec[order(id,sibid)]

  # drop datapoints if first sibling/respondent in id is outside cohort
  drop_ids <- survey_spec[,.(drop=ifelse((is.na(yob[1])|ageresp[1]<15|ageresp[1]>49),1,0)), by = "id"]
  drop_ids <- drop_ids[drop==1,]
  clean_ids <- survey_spec[!id%in%unique(drop_ids$id)]

  # add cohort names
  clean_ids[,agecat := paste0(cohort,'-',cohort+4)]

  # generate death periods
  clean_ids[,period := ((yr_interview-yod)%/% 5)*5]

  #assign age at death
  clean_ids[,age_at_death := ((yod-yob)%/%5)*5]

  # ------------------------------------------------

  # count by age_at_death, period, cohort
  proportions <- clean_ids[sex==2 & alive==0 & between(cohort, 15,49), .N, by=c('age_at_death','period','cohort')]
  proportions[, total := sum(N), by='cohort']
  proportions[,prop := N / total]

  # some surveys don't have v021
  # get proportions of sibs in each psu for assigning later on
  psu_grp <- setDT(count(clean_ids,v021))
  names(psu_grp)[names(psu_grp) == "n"] = "freq"
  if (nrow(psu_grp) > 1) {
    denom <- sum(psu_grp$freq)
    psu_grp[,prop := freq / denom]
    psu_grp <- psu_grp[order(-v021),]
    psu_grp[,cum_prop := 0]
    for (i in 1:nrow(psu_grp)) {
      if (i==1) {
        psu_grp[i,cum_prop := prop]
      }
      else {
        psu_grp[i,cum_prop := prop + psu_grp[i-1,cum_prop]]
      }
    }
    psu_grp[,n := 1]
    psu_grp <- psu_grp[,c('n','v021','cum_prop')]

    psu_grp <- dcast(psu_grp,n ~ v021, value.var = 'cum_prop')
  } else {
    psu_grp[, `:=`(n=1, cum_prop=1)]
    psu_grp[,c('n','v021'):=NULL]
  }

  # only keep siblings in sibships with 1 or 2 sibs
  names(clean_ids)[names(clean_ids) == "N"] = "sibsize"
  sibs <- clean_ids[sex==2 & (sibsize==2 | sibsize==1),]
  sibs <- sibs[order(id,sibid)]
  sibs[, `:=`(sib = 1:.N), by='id']

  # keep desired columns, original also included qline, n01
  weights <- sibs[,c('id','sib','cohort','alive','ageresp')]

  # get gk weighted age specific death rates
  weights <- weights[!is.na(alive),]

  weights[alive==1 & ageresp >= 15 & ageresp < 50,
             eligible_alive := 1]

  # add eligible sibs variable
  weights[,si_eligible := sum(eligible_alive,na.rm=T), by='id']
  weights[,birth := 1/si_eligible]
  weights[alive==0,dead := 1/si_eligible]
  # collapse to see deaths/births by cohort
  weights <- weights[,lapply(.SD,sum,na.rm=T),by=c('cohort'),.SDcols = c('birth','dead')]
  # generate ratios
  weights[, q := dead/birth]
  weights <- weights[,c('cohort','q','dead','birth')]

  # loop through below code until convergence
  convergence <- F
  i <- 1

  #####################################################################
  # initial aq0 is generated by frequency counts of dead/alive
  # The number of missing siblings is estimated based on calculations of aq0, which is dead/birth
  # On each iteration, add the number of missing sibships to the # of dead siblings, and recalculate aq0
  # When the number of missing siblings is no longer heavily impacted by updated aq0 (when the difference between iteration x and iteration x+1 < 0.1), stop
  #####################################################################
  while (!convergence & i<1000) {

    wide_counts <- merge(sibs, weights, by=c('cohort'),all.x=T)
    wide_counts <- wide_counts[order(id,cohort,alive),]
    wide_counts[, c('dead','birth'):= NULL]
    wide_counts[, sib := 1:.N, by='id']

    #reshape to wide format
    wide_counts <- dcast(wide_counts, id ~ sib, value.var = c('cohort','ageresp','alive','q'))

    # generate frequency counts,
    wide_counts <- wide_counts[,.N, by=c('alive_1','alive_2','cohort_1','cohort_2','q_1','q_2','ageresp_1','ageresp_2')]

    # cases: both sibs b/w 15-49
    wide_counts[ageresp_1 %between% c(15,49) & ageresp_2 %between% c(15,49),
                `:=` (miss1=N/(1-q_1*q_2)*(q_1*q_2), miss2=N/(1-q_1*q_2)*(q_1*q_2))]


    # if one sibling is outside the range 15-49:
    wide_counts[!(ageresp_2 %between% c(15,49)) | is.na(ageresp_2),
                miss1 := (N/(1-q_1)*(q_1*q_2)) + (N/(1-q_1)*(q_1*(1-q_2)))]
    wide_counts[!(ageresp_1 %between% c(15,49)) | is.na(ageresp_1),
                miss2 := (N/(1-q_2)*(q_1*q_2)) + (N/(1-q_2)*(q_2*(1-q_1)))]

    # if only 1 sibling
    wide_counts[is.na(alive_2), miss1 := N/(1-q_1)*q_1]
    wide_counts[is.na(alive_1), miss2 := N/(1-q_2)*q_2]

    #compare missing counts with last iteration
    wide_counts <- wide_counts[,c('cohort_1','cohort_2','miss1','miss2')]
    wide_counts <- wide_counts[order(cohort_1,cohort_2,miss1,miss2)]

    #reshape long
    wide_counts[,n := 1:.N]
    missing1 = melt(wide_counts,id.vars = "n",measure=patterns("cohort_", "miss"),variable.factor = F)
    missing1$variable = as.numeric(missing1$variable)
    setnames(missing1,c("variable","value1","value2"),c("sib","cohort","miss"))

    if (i > 1) {
      missing <- merge(missing1,missing,by=c('n','cohort','sib'), suffixes = c('1','2'))
      total_i <- sum(missing[,miss1], na.rm=T)
      total_j <- sum(missing[,miss2], na.rm=T)
      total_diff <- total_i - total_j
      print(total_diff)
      if (abs(total_diff) < 0.1) {
        final_missing <- missing[,c('cohort','sib','n', 'miss1')]
        convergence <- T
      }
      missing[,miss2 := NULL]
      setnames(missing, "miss1", "miss")
    } else {
      missing <- copy(missing1)
    }

    # recalculate qx to update weights dataset
    miss_sum <- missing1[,sum(miss, na.rm = T),by='cohort']
    weights <- merge(miss_sum, weights, by='cohort', all=F)
    weights[, birth_update := V1 + birth]
    weights[, death_update := V1 + dead]
    weights[, q := death_update / birth_update]
    weights <- weights[,c('cohort','q','dead','birth')]
    i <- i+1
  }
  ########################################
  # End of convergence loop
  #######################################
  out <- copy(final_missing)

  out <- out[!is.na(miss1),]
  out[, sib := as.integer(sib)]
  out[,sib := .N, by=c('n','cohort')]

  # Collapse missing siblings by age cohort, and assign based on death probabilities calcualted earlier

  output <- out[, sum(miss1), by='cohort']
  output <- merge(output, proportions, by='cohort')
  output[, missing := round(V1 * prop)]
  output[, yob := min_interview_yr - (cohort + 2)]
  output[, yod := floor(min_interview_yr-(period/2)-((cohort-age_at_death)/2)-1)]

  missing_sibs <- output[F]
  for (m in unique(output$missing)) {
    subs <- output[missing==m]
    for (i in 1:m) {
      missing_sibs <- rbind(missing_sibs, subs)
    }
  }
  missing_sibs <- missing_sibs[,c('yob','yod')]
  missing_sibs[, `:=`(alive=0, sex=2, yr_interview=min_interview_yr, surveyyear=min_interview_yr-1, svy=survey, sibid=1:.N, n=1)]

  missing_sibs <- merge(missing_sibs, psu_grp, by='n')
  missing_sibs[,`:=`(v021='', rand=runif(.N))]

  cum_propcols <- grep('^[0-9]*$',names(missing_sibs), value=T)
  for (col in cum_propcols){
    missing_sibs[get(col) > rand, v021 := col]
  }
  missing_sibs[, c(cum_propcols, 'n') := NULL]
  if (survey == unique(input$svy[1])) {
    all_surveys <- missing_sibs[F]
  }
  all_surveys <- rbind(all_surveys, missing_sibs)
}

# format for appending to main dataset
# Needed columns for regression: age, sex, yod, yob, alive, id_sm, v005, surveyyear, sibid

all_surveys[, missing_sib := 1]
all_surveys[, id := .GRP, by='svy']
all_surveys[, id := paste0(id, sibid)]
all_surveys[, sibid := 0]

# Missing siblings determined, now to add to main dataset
all_sibs <- setDT(rbind.fill(input, all_surveys))

# Add Identifying variables
all_sibs[, iso3 := substr(svy,1,3)]
all_sibs[is.na(missing_sib), surveyyear := as.numeric(substr(svy,10,14))-1]
all_sibs[is.na(missing_sib), missing_sib:=0]
# double check for unique ids
all_sibs[, id := paste0(id, missing_sib)]

# merge onto location
locs <- get_locations()[,c('ihme_loc_id','location_name')]
all_sibs <- merge(all_sibs, locs, by.x = 'iso3', by.y='ihme_loc_id')

# Create new sibship and PSU IDs
all_sibs[, `:=`(newid=paste0(id,"-",svy),strpsu=as.character(v021))]
all_sibs[, uniquepsu := paste0(location_name,'-',surveyyear,'-',strpsu)]

all_sibs[, id_sm := .GRP, by='newid']
all_sibs[, psu := .GRP, by='uniquepsu']


# drop unneeded values
all_sibs[, c('id','newid','strpsu','v021','uniquepsu') := NULL]

# check column types
sapply(all_sibs, class)

# coerce int columns to int, this may change
int_cols <- c('yob','yod','alive','sex','yr_interview','surveyyear','sibid','missing_sib','ageresp','id_sm','psu')
all_sibs[, (int_cols):=lapply(.SD, as.integer), .SDcols=int_cols]


# Write output
fwrite(all_sibs, "FILEPATH")

