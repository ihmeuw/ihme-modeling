# Zero Survivor Correction Script - 1st step in sibling survival process
# Description: estimates number of missing siblings due to zero reporter bias
#
# - look at https://iussp.org/sites/default/files/event_call_for_papers/Sibling%20survival%20paper.pdf for more detailed information
# - Watch out for improper formatting, some columns may be inconsistent across all surveys
# - Input: sibling history for a specific country-year
# - Output: sibling history, with missing siblings added

# Configure R
library(readr)
library(glue)
library(data.table)
library(plyr)
library(dplyr)
library(parallel)
library(mortdb)
rm(list = ls())

user <- "USERNAME"
if (Sys.info()[1] == "Windows") {
  root <- "FILEPATH"
  h_root <- "FILEPATH"
} else {
  root <- "FILEPATH"
  h_root <- "FILEPATH"
}
gbd_year <- 2023
source_file <- "FILEPATH"

sib_dir <- "FILEPATH"
loc_file <- fread(source_file)

locs <- get_locations(gbd_year = 2023)[, c("ihme_loc_id", "location_name")]
new_snnp <- c(
  "Sidama",
  "South West",
  "Southern Nations, Nationalities, and Peoples"
)
new_snnp <- locs[location_name %in% new_snnp, ihme_loc_id]

input <- data.table()
lim_sibs <- c("ETH_60908_2016", "ETH_94364_2016", "ETH_95069_2016")

for (i in 1:nrow(loc_file)) {
  loc <- loc_file[i, iso3]
  input_svy <- loc_file[i, svy]
  yr <- loc_file[i, year]
  input_dir <- loc_file[i, input_dir]

  print(input_svy)

  # Load in formatted sib history
  loc_input <- glue("FILEPATH/{input_svy}_sibhistories_formatted.csv") |>
    fread()
  input <- rbind(input, loc_input, fill = T)
}

input[, yod := as.integer(yod)]

for (survey in unique(input$svy)) {
  print(survey)
  survey_spec <- input[svy == survey, ]

  # get rid of nonsensical years of birth
  survey_spec[yob < 0, yob := NaN]

  # earliest interview year
  min_interview_yr <- min(survey_spec[, yr_interview])

  # count number of females in a sibship
  sibsizes <- survey_spec[sex == 2, .N, by = "id"]
  survey_spec <- merge(survey_spec, sibsizes, by = "id", all.x = T, sort = T)

  # assign age cohorts
  survey_spec[, cohort := ((yr_interview - yob) %/% 5) * 5]
  survey_spec[cohort > 85, cohort := NA]

  # generate ageresp
  survey_spec[, ageresp := yr_interview - yob]

  # sort by id, sibid
  survey_spec <- survey_spec[order(id, sibid)]

  # drop datapoints if first sibling/respondent in id is outside cohort
  drop_ids <- survey_spec[, .(drop = ifelse(
    (is.na(yob[1]) | ageresp[1] < 15 | ageresp[1] > 49),
    1, 0
  )),
  by = "id"
  ]
  drop_ids <- drop_ids[drop == 1, ]
  clean_ids <- survey_spec[!id %in% unique(drop_ids$id)]

  # add cohort names
  clean_ids[, agecat := paste0(cohort, "-", cohort + 4)]

  # generate death periods
  clean_ids[, period := ((yr_interview - yod) %/% 5) * 5]

  # assign age at death
  clean_ids[, age_at_death := ((yod - yob) %/% 5) * 5]

  # ------------------------------------------------

  # get proportions of sibs in each psu for assigning later on
  psu_grp <- setDT(count(clean_ids, v021))
  names(psu_grp)[names(psu_grp) == "n"] <- "freq"
  if (nrow(psu_grp) > 1) {
    denom <- sum(psu_grp$freq)
    psu_grp[, prop := freq / denom]
    psu_grp <- psu_grp[order(-v021), ]
    psu_grp[, cum_prop := cumsum(prop)]
    psu_grp[, n := 1]
    psu_grp <- psu_grp[, c("n", "v021", "cum_prop")]

    psu_grp <- dcast(psu_grp, n ~ v021, value.var = "cum_prop")
  } else {
    psu_grp[, `:=`(n = 1, cum_prop = 1)]
    psu_grp[, c("n", "v021") := NULL]
  }

  # only keep female siblings in sibships with 1 or 2 sibs (including respondent)
  names(clean_ids)[names(clean_ids) == "N"] <- "sibsize"
  sibs <- clean_ids[sex == 2 & (sibsize == 2 | sibsize == 1), ]
  sibs <- sibs[order(id, sibid)]
  sibs[, sib := 1:.N, by = "id"]

  # keep desired columns, original also included qline, n01
  weights <- sibs[, c("id", "sib", "cohort", "alive", "ageresp")]

  # get gk weighted age specific death rates
  weights <- weights[!is.na(alive), ]

  # GK weights apply to 15-49-year-olds
  weights[
    alive == 1 & ageresp >= 15 & ageresp < 50,
    eligible_alive := 1
  ]

  # add eligible sibs variable
  weights[, si_eligible := sum(eligible_alive, na.rm = T), by = "id"]
  weights[, birth := 1 / si_eligible]
  weights[alive == 0, dead := 1 / si_eligible]
  weights <- weights[, lapply(.SD, sum, na.rm = T),
    by = c("cohort"),
    .SDcols = c("birth", "dead")
  ]
  weights[, q := dead / birth]
  weights <- weights[, c("cohort", "q", "dead", "birth")]

  convergence <- F
  i <- 1

  #####################################################################
  # Idea: initial aq0 is generated by frequency counts of dead/alive
  # The number of missing siblings is estimated based on calculations of aq0, which is dead/birth
  # On each iteration, add the number of missing sibships to the # of dead siblings, and recalculate aq0
  # When the number of missing siblings is no longer heavily impacted by updated aq0 (when the difference between iteration x and iteration x+1 < 0.1), stop
  #####################################################################
  while (!convergence & i < 1000) {
    wide_counts <- merge(sibs, weights, by = c("cohort"), all.x = T)
    wide_counts <- wide_counts[order(id, cohort, alive), ]
    wide_counts[, c("dead", "birth") := NULL]
    wide_counts[, sib := 1:.N, by = "id"]

    # reshape to wide format
    wide_counts_cols <- c("alive", "cohort", "q", "ageresp")
    wide_counts <- dcast(wide_counts, id ~ sib, value.var = wide_counts_cols)

    # generate frequency counts,
    wide_counts_group <- paste0(
      rep(wide_counts_cols, 2),
      "_",
      rep(c(1, 2), each = 4)
    )
    wide_counts <- wide_counts[, .N, by = wide_counts_group]

    # case 1: both siblings between 15-49
    wide_counts[
      between(ageresp_1, 15, 49) & between(ageresp_2, 15, 49),
      c("miss1", "miss2") := N / (1 - q_1 * q_2) * (q_1 * q_2)
    ]

    # case 2: one sibling outside of 15-49 range
    wide_counts[
      !between(ageresp_2, 15, 49) | is.na(ageresp_2),
      miss1 := (N / (1 - q_1) * (q_1 * q_2)) + (N / (1 - q_1) * (q_1 * (1 - q_2)))
    ]
    wide_counts[
      !between(ageresp_1, 15, 49) | is.na(ageresp_1),
      miss2 := (N / (1 - q_2) * (q_1 * q_2)) + (N / (1 - q_2) * (q_2 * (1 - q_1)))
    ]

    # case 3: respondent is the only eligible sibling
    wide_counts[is.na(alive_2), miss1 := N / (1 - q_1) * q_1]
    wide_counts[is.na(alive_1), miss2 := N / (1 - q_2) * q_2]

    # compare missing counts with last iteration
    wide_counts <- wide_counts[, c("cohort_1", "cohort_2", "miss1", "miss2")]
    wide_counts <- wide_counts[order(cohort_1, cohort_2, miss1, miss2)]

    # reshape long
    wide_counts[, n := 1:.N]
    missing1 <- data.table::melt(wide_counts,
      id.vars = "n",
      measure = patterns("cohort_", "miss"),
      variable.factor = F
    )
    missing1[, variable := as.numeric(variable)]
    setnames(
      missing1,
      c("variable", "value1", "value2"),
      c("sib", "cohort", "miss")
    )

    if (i > 1) {
      missing <- missing1 |>
        merge(missing, by = c("n", "cohort", "sib"), suffixes = c("1", "2"))
      total_i <- sum(missing[, miss1], na.rm = T)
      total_j <- sum(missing[, miss2], na.rm = T)
      total_diff <- total_i - total_j
      print(total_diff)
      if (abs(total_diff) < 0.1) {
        final_missing <- missing[, c("cohort", "sib", "n", "miss1")]
        convergence <- T
      }
      missing[, miss2 := NULL]
      setnames(missing, "miss1", "miss")
    } else {
      missing <- copy(missing1)
    }

    # recalculate qx to update weights dataset
    miss_sum <- missing1[, sum(miss, na.rm = T), by = "cohort"]
    weights <- merge(miss_sum, weights, by = "cohort", all = F)
    weights[, `:=`(
      birth_update = V1 + birth,
      death_update = V1 + dead
    )]
    weights[, q := death_update / birth_update]
    weights <- weights[, c("cohort", "q", "dead", "birth")]
    i <- i + 1
  }
  # End of convergence loop

  out <- copy(final_missing)
  out <- out[!is.na(miss1), ]
  out[, sib := as.integer(sib)]
  out[, sib := .N, by = c("n", "cohort")]

  # Randomly assign life attributes for missing siblings:
  ## year of birth: within 5-year range associated with cohort
  ## year of death: any year between year of birth and year of interview

  output <- out[, round(sum(miss1)), by = "cohort"]
  setnames(output, "V1", "missing")

  missing_sibs <- output[F]
  for (m in unique(output$missing)) {
    if (m == 0) {
      next
    }
    subs <- output[missing == m]
    for (i in 1:m) {
      missing_sibs <- rbind(missing_sibs, subs)
    }
  }
  set.seed(5)
  missing_sibs[, cohort := min_interview_yr - cohort]
  for (i in 1:nrow(missing_sibs)) {
    missing_sibs[i, yob := sample((cohort - 4):cohort, 1)]
    missing_sibs[i, yod := sample(yob:min_interview_yr, 1)]
  }

  missing_sibs <- missing_sibs[, .(yob, yod)]
  missing_sibs[, `:=`(
    alive = 0,
    sex = 2,
    yr_interview = min_interview_yr,
    surveyyear = min_interview_yr - 1,
    svy = survey,
    sibid = 1:.N,
    n = 1
  )]

  missing_sibs <- merge(missing_sibs, psu_grp, by = "n")
  missing_sibs[, `:=`(v021 = "", rand = runif(.N))]

  cum_propcols <- grep("^[0-9]*$", names(missing_sibs), value = T)
  for (col in cum_propcols) {
    missing_sibs[get(col) > rand, v021 := col]
  }
  missing_sibs[, c(cum_propcols, "n") := NULL]
  if (survey == unique(input$svy[1])) {
    all_surveys <- missing_sibs[F]
  }
  all_surveys <- rbind(all_surveys, missing_sibs)
}


# Include columns necessary for regression:
## age, sex, yod, yob, alive, id_sm, v005, surveyyear, sibid
all_surveys[, missing_sib := 1]
all_surveys[, id := .GRP, by = "svy"]
all_surveys[, id := paste0(id, sibid)]
all_surveys[, sibid := 0]

# Missing siblings determined, now to add to main dataset
all_sibs <- setDT(rbind.fill(input, all_surveys))

# Add Identifying variables
all_sibs[, iso_year := as.integer(regexpr("_(1|2)", svy))]
all_sibs[, iso3 := substr(svy, 1, iso_year - 1)]
all_sibs[
  is.na(missing_sib),
  surveyyear := as.numeric(substr(svy, iso_year + 1, iso_year + 4)) - 1
]
all_sibs[is.na(missing_sib), missing_sib := 0]
all_sibs[, iso_year := NULL]
# double check for unique ids
all_sibs[, id := paste0(id, missing_sib)]

# merge onto location
all_sibs <- merge(all_sibs, locs, by.x = "iso3", by.y = "ihme_loc_id")

# Create new sibship and PSU IDs
all_sibs[, `:=`(newid = paste0(id, "-", svy), strpsu = as.character(v021))]
all_sibs[, uniquepsu := paste0(location_name, "-", surveyyear, "-", strpsu)]

all_sibs[, id_sm := .GRP, by = "newid"]
all_sibs[, psu := .GRP, by = "uniquepsu"]

# drop unnecessary values
all_sibs[, c("id", "newid", "strpsu", "v021", "uniquepsu") := NULL]

# check column types
sapply(all_sibs, class)

# coerce certain columns to integers
int_cols <- c(
  "yob", "yod", "alive", "sex", "yr_interview", "surveyyear",
  "sibid", "missing_sib", "id_sm", "psu"
)
all_sibs[, (int_cols) := lapply(.SD, as.integer), .SDcols = int_cols]

# Upload files
## Full group
all_sibs |>
  fwrite(paste0("FILEPATH/allsibhistories_with_missing_sibs.csv"))

## Individual locs
for (input_svy in unique(all_sibs[, svy])) {
  print(input_svy)
  output_dir <- loc_file[svy == input_svy, output_dir]
  all_sibs_loc <- all_sibs[svy == input_svy]
  if (output_dir |> length() == 0) {
    next
  }
  dir_create(output_dir, recurse = T, mode = "775")
  all_sibs_loc |>
    fwrite(glue("FILEPATH/{input_svy}_sibhistories_with_missing_sibs.csv"))
}
